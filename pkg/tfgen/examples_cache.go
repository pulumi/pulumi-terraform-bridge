// Copyright 2016-2024, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Facilities to help caching the example generation. Generating examples is expensive, especially
// when using the convert_cli.go method that interacts with an external process. Typically provider
// builds first generate the schema, and then generate concrete language SDKs for Python, TypeScript
// and so on; these processes start from scratch as they do not easily decompose into passes, and
// naively they perform the conversion work multiple times. Using a file-based cache speeds up the
// process by avoiding repeat conversion.
package tfgen

import (
	"bytes"
	"crypto/md5" //nolint:gosec
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/pulumi/pulumi/sdk/v3/go/common/util/contract"
)

const (
	pulumiConvertExamplesCacheDirEnvVar = "PULUMI_CONVERT_EXAMPLES_CACHE_DIR"
)

type examplesCache struct {
	enabled             bool
	dir                 string
	ProviderName        string                       `json:"providerName"`
	ProviderVersion     string                       `json:"providerVersion"`
	PulumiVersion       string                       `json:"pulumiVersion"`
	BuildFileHashes     map[string]string            `json:"buildFileHashes"`
	Plugins             map[string]map[string]string `json:"plugins"`
	CliConverterEnabled bool                         `json:"cliConverterEnabled"`
}

func (g *Generator) getOrCreateExamplesCache() *examplesCache {
	if g.examplesCache == nil {
		g.examplesCache = newExamplesCache(g.info.Name, g.version, "" /* infer from env var */)
	}
	return g.examplesCache
}

func newExamplesCache(providerName string, providerVersion, cacheDir string) *examplesCache {
	dir := cacheDir
	enabled := true
	if dir == "" {
		dir, enabled = os.LookupEnv(pulumiConvertExamplesCacheDirEnvVar)
	}
	if !enabled {
		return &examplesCache{}
	}
	ec := &examplesCache{
		enabled:         true,
		dir:             dir,
		ProviderName:    providerName,
		ProviderVersion: providerVersion,
	}
	ec.inferToolingVersions()
	ec.prepareDir()
	return ec
}

func (ec *examplesCache) Lookup(originalHCL, language string) (string, bool) {
	if !ec.enabled {
		return "", false
	}
	k := ec.exampleKey(originalHCL, language)
	p := filepath.Join(ec.fulldir(), k)
	bytes, err := os.ReadFile(p)
	if err != nil {
		return "", false
	}
	return string(bytes), true
}

func (ec *examplesCache) Store(originalHCL, language, result string) {
	if !ec.enabled {
		return
	}
	// ignore placeholders generated by convert_cli.go
	if strings.HasPrefix(result, "{convertExamples:") {
		return
	}
	k := ec.exampleKey(originalHCL, language)
	p := filepath.Join(ec.fulldir(), k)
	err := os.WriteFile(p, []byte(result), 0600)
	contract.AssertNoErrorf(err, "failed to write to the examples cache")
}

func (*examplesCache) checksum(bytes []byte) string {
	hash := md5.Sum(bytes) //nolint:gosec
	return hex.EncodeToString(hash[:])
}

func (ec *examplesCache) exampleKey(originalHCL, language string) string {
	sep := "|"
	var buf bytes.Buffer
	fmt.Fprintf(&buf, "originalHCL=%v%s", originalHCL, sep)
	fmt.Fprintf(&buf, "language=%v%s", language, sep)
	return ec.checksum(buf.Bytes())
}

func (ec *examplesCache) inferToolingVersions() {
	ec.PulumiVersion = ec.inferPulumiVersion()
	ec.Plugins = ec.inferPlugins()
	ec.BuildFileHashes = ec.inferBuildFileHashes()
	ec.CliConverterEnabled = cliConverterEnabled()
}

func (*examplesCache) inferPulumiVersion() string {
	pv, err := exec.Command("pulumi", "version").CombinedOutput()
	contract.AssertNoErrorf(err, "`pulumi version` failed")
	return strings.TrimSpace(string(pv))
}

func (*examplesCache) inferPlugins() map[string]map[string]string {
	j, err := exec.Command("pulumi", "plugin", "ls", "--json").CombinedOutput()
	contract.AssertNoErrorf(err, "`pulumi plugin ls --json` failed")
	type info struct {
		Name    string `json:"name"`
		Kind    string `json:"kind"`
		Version string `json:"version"`
	}

	var infos []info
	err = json.Unmarshal(j, &infos)
	contract.AssertNoErrorf(err, "`pulumi plugin ls --json` output parsing failed")

	rr := map[string]map[string]string{}
	for _, i := range infos {
		if _, ok := rr[i.Kind]; !ok {
			rr[i.Kind] = map[string]string{}
		}

		rr[i.Kind][i.Name] = i.Version
	}
	return rr
}

func (ec *examplesCache) inferBuildFileHashes() map[string]string {
	candidates := []string{
		"go.work",
		"go.work.sum",
		filepath.Join("provider", "go.mod"),
		filepath.Join("provider", "go.sum"),
	}
	rr := map[string]string{}
	for _, c := range candidates {
		rr[c] = ec.filehash(c)
	}
	return rr
}

func (ec *examplesCache) filehash(p string) string {
	bytes, err := os.ReadFile(p)
	if err != nil {
		return ""
	}
	return ec.checksum(bytes)
}

func (ec *examplesCache) uniqueDirHash() string {
	bytes, err := json.Marshal(ec)
	contract.AssertNoErrorf(err, "examplesCache should marshal to JSON")
	return ec.checksum(bytes)
}

func (ec *examplesCache) fulldir() string {
	return filepath.Join(ec.dir, ec.uniqueDirHash())
}

func (ec *examplesCache) prepareDir() {
	d := ec.fulldir()
	err := os.MkdirAll(d, 0755)
	contract.AssertNoErrorf(err, "failed to prepare dir specified by %q",
		pulumiConvertExamplesCacheDirEnvVar)

	bytes, err := json.Marshal(ec)
	contract.AssertNoErrorf(err, "examplesCache should marshal to JSON")

	err = os.WriteFile(filepath.Join(d, "cache.json"), bytes, 0600)
	contract.AssertNoErrorf(err, "failed to write cache.json")
}
