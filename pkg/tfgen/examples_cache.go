// Copyright 2016-2024, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Facilities to help caching the example generation. Generating examples is expensive, especially
// when using the convert_cli.go method that interacts with an external process. Typically provider
// builds first generate the schema, and then generate concrete language SDKs for Python, TypeScript
// and so on; these processes start from scratch as they do not easily decompose into passes, and
// naively they perform the conversion work multiple times. Using a file-based cache speeds up the
// process by avoiding repeat conversion.
package tfgen

import (
	"bytes"
	"crypto/md5" //nolint:gosec
	"encoding/hex"
	"encoding/json"
	"fmt"
	"maps"
	"os"
	"os/exec"
	"path/filepath"
	"runtime/debug"
	"slices"
	"strings"

	"github.com/pulumi/pulumi/sdk/v3/go/common/util/contract"

	"github.com/pulumi/pulumi-terraform-bridge/v3/pkg/tfbridge"
)

const (
	pulumiConvertExamplesCacheDirEnvVar = "PULUMI_CONVERT_EXAMPLES_CACHE_DIR"
)

type examplesCache struct {
	enabled             bool
	dir                 string
	ProviderName        string                       `json:"providerName"`
	PulumiVersion       string                       `json:"pulumiVersion"`
	SoftwareVersions    map[string]string            `json:"softwareVersions"`
	Plugins             map[string]map[string]string `json:"plugins"`
	CliConverterEnabled bool                         `json:"cliConverterEnabled"`
	ProviderInfoHash    string                       `json:"providerInfoHash"`
}

func (g *Generator) getOrCreateExamplesCache() *examplesCache {
	if g.examplesCache == nil {
		g.examplesCache = newExamplesCache(&g.info, "" /* infer from env var */)
	}

	return g.examplesCache
}

func newExamplesCache(info *tfbridge.ProviderInfo, cacheDir string) *examplesCache {
	providerName := info.Name
	dir := cacheDir
	enabled := true
	if dir == "" {
		dir, enabled = os.LookupEnv(pulumiConvertExamplesCacheDirEnvVar)
		// If the provider author is debugging schema generation, example cache may get in the way of getting
		// accurate results - there are some problems at the intersection of using Go workspaces and computing
		// accurate keys. Disable it.
		_, convertOnly := os.LookupEnv("PULUMI_CONVERT_ONLY")
		if convertOnly {
			enabled = false
		}
	}
	if !enabled {
		return &examplesCache{}
	}
	contract.Assertf(dir != "", `Invalid %s=""`, pulumiConvertExamplesCacheDirEnvVar)
	ec := &examplesCache{
		enabled:      true,
		dir:          dir,
		ProviderName: providerName,
	}
	ec.computeProviderInfoHash(info)
	ec.inferToolingVersions()
	ec.prepareDir()
	return ec
}

func (ec *examplesCache) Lookup(originalHCL, language string) (string, bool) {
	if !ec.enabled {
		return "", false
	}
	k := ec.exampleKey(originalHCL, language)
	p := filepath.Join(ec.fulldir(), k)
	bytes, err := os.ReadFile(p)
	if err != nil {
		return "", false
	}
	return string(bytes), true
}

func (ec *examplesCache) Store(originalHCL, language, result string) {
	if !ec.enabled {
		return
	}
	// ignore placeholders generated by convert_cli.go
	if strings.HasPrefix(result, "{convertExamples:") {
		return
	}
	k := ec.exampleKey(originalHCL, language)
	p := filepath.Join(ec.fulldir(), k)
	err := os.WriteFile(p, []byte(result), 0o600)
	contract.AssertNoErrorf(err, "failed to write to the examples cache")
}

func (*examplesCache) checksum(bytes []byte) string {
	hash := md5.Sum(bytes) //nolint:gosec
	return hex.EncodeToString(hash[:])
}

// exampleKey determines the cache key to use for the given HCL. It's computed
// from the HCL, target language, our Pulumi & Bridge versions, and the
// provider's info.
func (ec *examplesCache) exampleKey(originalHCL, language string) string {
	var buf bytes.Buffer

	fmt.Fprint(&buf, originalHCL)
	fmt.Fprint(&buf, language)
	fmt.Fprint(&buf, ec.ProviderInfoHash)

	// Sorted for stable keys.
	for _, key := range slices.Sorted(maps.Keys(ec.SoftwareVersions)) {
		fmt.Fprint(&buf, key)
		fmt.Fprint(&buf, ec.SoftwareVersions[key])
	}

	return ec.checksum(buf.Bytes())
}

func (ec *examplesCache) inferToolingVersions() {
	ec.PulumiVersion = ec.inferPulumiVersion()
	ec.Plugins = ec.inferPlugins()
	ec.CliConverterEnabled = cliConverterEnabled()
	ec.SoftwareVersions = ec.inferSoftwareVersions()
}

func (*examplesCache) inferPulumiVersion() string {
	pv, err := exec.Command("pulumi", "version").CombinedOutput()
	contract.AssertNoErrorf(err, "`pulumi version` failed")
	return strings.TrimSpace(string(pv))
}

func (*examplesCache) inferPlugins() map[string]map[string]string {
	j, err := exec.Command("pulumi", "plugin", "ls", "--json").CombinedOutput()
	contract.AssertNoErrorf(err, "`pulumi plugin ls --json` failed")
	type info struct {
		Name    string `json:"name"`
		Kind    string `json:"kind"`
		Version string `json:"version"`
	}

	var infos []info
	err = json.Unmarshal(j, &infos)
	contract.AssertNoErrorf(err, "`pulumi plugin ls --json` output parsing failed")

	rr := map[string]map[string]string{}
	for _, i := range infos {
		if _, ok := rr[i.Kind]; !ok {
			rr[i.Kind] = map[string]string{}
		}

		rr[i.Kind][i.Name] = i.Version
	}
	return rr
}

func (ec *examplesCache) inferSoftwareVersions() map[string]string {
	v := map[string]string{}

	bi, ok := debug.ReadBuildInfo()
	if !ok {
		return v
	}

	for _, mod := range bi.Deps {
		if mod.Replace != nil {
			mod = mod.Replace
		}

		switch mod.Path {
		case "github.com/pulumi/pulumi/pkg/v3",
			"github.com/pulumi/pulumi/sdk/v3",
			"github.com/pulumi/pulumi-terraform-bridge/v3":

			v[mod.Path] = mod.Version
		default:
		}
	}

	return v
}

func (ec *examplesCache) computeProviderInfoHash(info *tfbridge.ProviderInfo) {
	mpi := tfbridge.MarshalProviderInfo(info)
	bytes, err := json.Marshal(mpi)
	contract.AssertNoErrorf(err, "failed to marshal MarshallableProviderInfo to JSON")
	ec.ProviderInfoHash = ec.checksum(bytes)
}

func (ec *examplesCache) uniqueDirHash() string {
	bytes, err := json.Marshal(ec)
	contract.AssertNoErrorf(err, "examplesCache should marshal to JSON")
	return ec.checksum(bytes)
}

func (ec *examplesCache) fulldir() string {
	return filepath.Join(ec.dir, ec.uniqueDirHash())
}

func (ec *examplesCache) prepareDir() {
	d := ec.fulldir()
	err := os.MkdirAll(d, 0o755)
	contract.AssertNoErrorf(err, "failed to prepare dir specified by %q",
		pulumiConvertExamplesCacheDirEnvVar)

	bytes, err := json.Marshal(ec)
	contract.AssertNoErrorf(err, "examplesCache should marshal to JSON")

	err = os.WriteFile(filepath.Join(d, "cache.json"), bytes, 0o600)
	contract.AssertNoErrorf(err, "failed to write cache.json")
}
