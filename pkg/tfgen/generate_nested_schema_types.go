package tfgen

import (
	"github.com/pulumi/inflector"
	"github.com/pulumi/pulumi/pkg/v3/codegen"
	"github.com/pulumi/pulumi/sdk/v3/go/common/util/contract"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/pulumi/pulumi-terraform-bridge/v3/pkg/tfgen/internal/paths"
)

// schemaNestedType is a schema for a "nested" (some type "nested" under the main module) type
// this will be used to generate the pschema spec for the type
type schemaNestedType struct {
	typ             *propertyType
	declarer        declarer
	required        codegen.StringSet
	requiredInputs  codegen.StringSet
	requiredOutputs codegen.StringSet

	// The same *propertyType may be found at multiple typePaths and reused. Non-empty.
	typePaths paths.TypePathSet
}

// schemaNestedTypes
// this will be used to generate the pschema.ObjectTypeSpec spec for the type
type schemaNestedTypes struct {
	nameToType map[string]*schemaNestedType
}

// gatherSchemaNestedTypesForModule generates the schema types for each "member" of the module,
// i.e. `resourceType`s, `resourceFunc`s, & `variable`s
func gatherSchemaNestedTypesForModule(mod *module) map[string]*schemaNestedType {
	nt := &schemaNestedTypes{
		nameToType: make(map[string]*schemaNestedType),
	}
	for _, member := range mod.members {
		nt.gatherFromMember(member)
	}
	return nt.nameToType
}

// gatherSchemaNestedTypesForMember generates the schema types for a moduleMember
// currently this is only used to for the `provider` resourceType
func gatherSchemaNestedTypesForMember(member moduleMember) map[string]*schemaNestedType {
	nt := &schemaNestedTypes{
		nameToType: make(map[string]*schemaNestedType),
	}
	nt.gatherFromMember(member)
	return nt.nameToType
}

func (nt *schemaNestedTypes) gatherFromMember(member moduleMember) {
	switch member := member.(type) {
	case *resourceType:
		p := member.resourcePath
		nt.gatherFromProperties(p.Inputs(), member, newNestedTypeGraph(member.name), member.inprops, true)
		nt.gatherFromProperties(p.Outputs(), member, newNestedTypeGraph(member.name), member.outprops, false)
		// a "provider" is also a `resourceType`
		if !member.IsProvider() {
			nt.gatherFromProperties(p.State(), member, newNestedTypeGraph(member.name), member.statet.properties, true)
		}
	case *resourceFunc:
		p := member.dataSourcePath
		nt.gatherFromProperties(p.Args(), member, newNestedTypeGraph(member.name), member.args, true)
		nt.gatherFromProperties(p.Results(), member, newNestedTypeGraph(member.name), member.rets, false)
	case *variable:
		contract.Assertf(member.config, `member.config`)
		p := paths.NewProperyPath(paths.NewConfigPath(), member.propertyName)
		nt.gatherFromPropertyType(p, member, newNestedTypeGraph(member.name), "", member.typ, false)
	}
}

// declarer is the `moduleMember` (i.e. `resourceType`, `resourceFunc`, `variable`)
// that contains the nestedType
type declarer interface {
	Name() string
}

type nestedTypeNode struct {
	// The possible paths which end in the current nestedType node
	paths []string

	// The original name that is generated by using the longest path
	// to this type node
	longestPathName string
}

// nestedTypeGraph contains the current state of the type graph
type nestedTypeGraph struct {
	// The possible paths from the root node to the current node
	paths []string

	// The longest path to the current node in the graph
	// This will contain an entry for each parent node in the graph
	longestPath []string

	// The root node of the type graph
	// this will be the name of the `moduleMember`/`declarer`
	root string

	// Branches for a specific type node
	branches map[string]nestedTypeNode
}

func newNestedTypeGraph(resourceName string) nestedTypeGraph {
	return nestedTypeGraph{
		root:     resourceName,
		paths:    []string{},
		branches: map[string]nestedTypeNode{},
	}
}

func nameToPropertyName(parentName, name string) string {
	return parentName + cases.Title(language.Und, cases.NoLower).String(name)
}

// createBranch stores a branch in the type graph
// the branch will contain all the paths from the root to the current node
func (n nestedTypeGraph) createBranch(name string) nestedTypeGraph {
	if name == n.root {
		// this is the root node so just return the graph as is
		return n
	}
	// this is a top level property of the `moduleMember`
	// we've decided to always include the moduleMember.name and the top level
	// property name in the path for all nested properties under that top level property
	if len(n.paths) == 0 {
		propName := nameToPropertyName(n.root, name)
		n.paths = []string{propName}
		n.longestPath = n.paths
		n.branches[name] = nestedTypeNode{
			paths:           n.paths,
			longestPathName: propName,
		}
		return n
	}

	parentName := n.longestPath[len(n.longestPath)-1]
	node := nestedTypeNode{
		longestPathName: nameToPropertyName(parentName, name),
		paths:           []string{},
	}
	n.longestPath = append(n.longestPath, node.longestPathName)
	for _, path := range n.paths {
		// create the paths to the current node by appending the current node name
		// to each path
		node.paths = append(node.paths, nameToPropertyName(path, name))
	}
	// then add those branch paths to the graph paths
	n.paths = append(n.paths, node.paths...)
	n.branches[name] = node

	return n
}

func (n nestedTypeGraph) longestName(nodeName string) string {
	if node, ok := n.branches[nodeName]; ok {
		return node.longestPathName
	}
	// TODO: this can't be right
	return ""
}

// getNameForTypeNode gets the appropriate name for a typeNode.
// It will use the "longest" name unless it is > 120 characters (arbitrary number, 256 is max allowed in Java)
// in which case it will attempt to find a shorter name.
func (nt *schemaNestedTypes) getNameForTypeNode(
	typeGraph nestedTypeGraph,
	nodeName string,
	declarer declarer,
	typ *propertyType,
) string {
	name := typeGraph.longestName(nodeName)
	if len(name) > 120 {
		// name is too long, get a shorter name
		shorterName := nt.getShortestName(nodeName, typeGraph, declarer, typ)
		if shorterName != "" {
			return shorterName
		}
	}
	return name
}

// getShortestName attempts to get the shortest possible name available to a property.
// It does this by calculating the "shortest path" from the top level property.
// For example, suppose we had a schema that looked like this:
//
//	{
//	  "RootProp": {
//	    "NestedProp": {
//	      "SubNestedProp": {}
//	    }
//	  }
//	}
//
// The available "paths" from "RootProp" to "SubNestedProp" would be
//   - "RootProp" -> "NestedProp" -> "SubNestedProp"
//   - "RootProp" -> "SubNestedProp"
//
// So we would first try "RootPropSubNestedProp" since that is "shortest" (based on number of characters)
// and if it was unavailable (another property with a different type already has the name)
// then we would take the next shortest "RootPropNestedPropSubNestedProp"
func (nt *schemaNestedTypes) getShortestName(
	name string,
	typeGraph nestedTypeGraph,
	declarer declarer,
	typ *propertyType,
) string {

	var shortestName string
	shortestNameIdx := 0
	var branchLength int
	if branch, ok := typeGraph.branches[name]; ok {
		branchLength = len(branch.paths)
		shortestName = branch.paths[0]
		for i := 1; i < len(branch.paths); i++ {
			if len(branch.paths[i]) < len(shortestName) {
				shortestNameIdx = i
				shortestName = branch.paths[i]
			}
		}
		// remove the shortest name from the paths so that it does not get picked again when we recurse
		branch := typeGraph.branches[name]
		branch.paths = append(branch.paths[0:shortestNameIdx], branch.paths[shortestNameIdx+1:]...)
	}

	contract.Assertf(shortestName != "", "invalid type name %v", name)
	if branchLength <= 1 {
		return shortestName
	}

	if existing, ok := nt.nameToType[shortestName]; ok {
		// if we already have a type with this name and the types don't match
		// then we need to find the next shortest name
		if existing.declarer == declarer || existing.typ.equals(typ) {
			return shortestName
		}
		return nt.getShortestName(name, typeGraph, declarer, typ)
	}
	return shortestName
}

func (nt *schemaNestedTypes) gatherFromProperties(pathContext paths.TypePath,
	declarer declarer, typeGraph nestedTypeGraph, ps []*variable,
	isInput bool) {

	for _, p := range ps {
		name := p.name
		if p.typ.kind == kindList || p.typ.kind == kindSet {
			name = inflector.Singularize(name)
		}

		nt.gatherFromPropertyType(paths.NewProperyPath(pathContext, p.propertyName),
			declarer, typeGraph, name, p.typ, isInput)
	}
}

func (nt *schemaNestedTypes) gatherFromPropertyType(
	typePath paths.TypePath,
	declarer declarer,
	typeGraph nestedTypeGraph,
	name string,
	typ *propertyType,
	isInput bool,
) {

	switch typ.kind {
	case kindList, kindSet, kindMap:
		if typ.element != nil {
			nt.gatherFromPropertyType(paths.NewElementPath(typePath),
				declarer, typeGraph, name, typ.element, isInput)
		}
	case kindObject:
		baseName := nt.declareType(typePath, declarer, typeGraph, name, typ, isInput)
		nt.gatherFromProperties(typePath, declarer, baseName, typ.properties, isInput)
	}
}

func (nt *schemaNestedTypes) declareType(
	typePath paths.TypePath,
	declarer declarer,
	typeGraph nestedTypeGraph,
	name string,
	typ *propertyType,
	isInput bool,
) nestedTypeGraph {

	// Generate a name for this nested type.
	np := typeGraph.createBranch(name)
	typeName := nt.getNameForTypeNode(typeGraph, name, declarer, typ)

	// Override the nested type name, if necessary.
	if typ.nestedType.Name().String() != "" {
		typeName = typ.nestedType.Name().String()
	}

	typ.name = typeName

	required := codegen.StringSet{}
	for _, p := range typ.properties {
		if !p.optional() {
			required.Add(p.name)
		}
	}

	var requiredInputs, requiredOutputs codegen.StringSet
	if isInput {
		requiredInputs = required
	} else {
		requiredOutputs = required
	}

	// Merging makes sure that structurally identical types are shared and not generated more than once.
	if existing, ok := nt.nameToType[typeName]; ok {
		// TODO: is this right? The type can be different as long as the declarer is the same?
		contract.Assertf(existing.declarer == declarer || existing.typ.equals(typ), "duplicate type %v", typeName)

		// Remember that existing type is now also seen at the current typePath.
		existing.typePaths.Add(typePath)

		// For output type conflicts, record the output type's required properties. These will be attached to a
		// nodejs-specific blob in the object type's spec s.t. the node code generator can generate code that
		// matches the code produced by the old tfgen code generator.
		if isInput {
			existing.requiredInputs = requiredInputs
		} else {
			existing.requiredOutputs = requiredOutputs
		}

		existing.typ, existing.required = typ, required
		return np
	}

	nt.nameToType[typeName] = &schemaNestedType{
		typ:             typ,
		declarer:        declarer,
		required:        required,
		requiredInputs:  requiredInputs,
		requiredOutputs: requiredOutputs,
		typePaths:       paths.SingletonTypePathSet(typePath),
	}
	return np
}
